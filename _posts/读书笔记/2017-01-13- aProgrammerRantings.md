---
layout: post
title:  《程序员的呐喊》读书笔记
tags: 读书笔记
---

 <img src="/assets/img/aProgrammerRantings/cover.jpg" style="width:400px;height:400px;margin:0 auto;"/>

* content
{:toc}

### 1：摘录自“摩尔定律就是胡扯”一节

  经常有人会问我怎么有时间去学新东西。我在这里统一回答一下：**时间是挤出来的**。这个答案没人会喜欢，但你我都知道这是真理。
  我有个兄弟大卫，高中毕业以后体重暴增...
  有一天他瞧见一辆卡车的防撞栏上贴着一条小广告：“减肥找我！”。于是他在下个红灯赶上去，里面坐着两个牛仔，他问：“要怎样才能减肥？” 他们嘲笑道：“直接减啊，你个肥猪，哈哈哈哈！”接着扬长而去。
  大卫为此消沉了好一会儿，不过最终还是释怀了，因为他知道要这么做。果不其然，两年后他就是足球冠军校队的成员了。其实根本就没有什么神奇的法术，他只不过跑去买了辆山地车，然后拼命骑，定期跑健身房，控制饮食，一年之内就减掉了85磅。
  不过这些道理其实你早就懂了，是吗？
  
  **学习是一件很困难的事情。**要是你觉得很简单，那你肯定是在摸鱼，不去挑战自己做一些过去做不到的新事物，你是不可能提高自己的。
  研究已经知道的东西会很有吸引力，因为这样不会那么痛苦。
  要是你写的代码都不怎么费脑力，那么就算你真的在进步，那提高的速度也会慢到无法令人注意到。只有努力（哪怕不是天天）去做一些自己不懂的东西，才会拓展自己的眼界。
  待在学校是一件非常奢侈的事情，不过真的这样的时候很少有人意识到这一点，因为学习是很痛苦的事情。但是你可以相信我：荒废时间只会让人更痛苦。
  
  现在你开始明白我为什么喜欢和那些毕业以后仍然保持学习动力的程序员共事了吧？因为即便深陷泥潭（我们只不过是一群目不识丁的洞穴人，身处编程的石器时代），至少这些**天天向上**的程序员让我看到了一点希望。那种假如有更好的技术出现，他们会愿意去尝试，认真、努力去尝试的希望。我甚至希望他们会愿意和我一起来创造一些“更好的东西”
  
  如果你想要上进的话，唯一要做的就是**持之以恒**。不管你是想要提高编程水平，还是数学水平，或是想要健身，玩风筝，甚至克服人类比害怕死亡更甚的第一恐惧：公开演讲。只要脚踏实地，就能循序渐进。
  
  当然你肯定要**忍受学习的痛苦**，每天努力一点，习惯成自然。
  
### 2：摘录自“土豪程序员的美食”一节
  我在招人的时候有一个诀窍。就是在寻找优秀的软件工程师"通才"的时候，"编译器"是我唯一感兴趣的词。通常在简历上你可以看到各种让你觉得不行的关键字和词。只有很少的一些词能让你眼前一亮，我的意思是"在一场传统的面试中胜出的可能性比较高"。而"编译器"就是其中最惹眼的词之一。
  玩编译器的人通常在面试里的表现都会相当出色，不管有没有被问到和编译器有关的问题。相反，对编译器一无所知的人往往在计算机科学教育和对系统架构的整体把握上有缺陷。

  千万别学我。**工作以后想要再静下心来读书就很难了**，先拿学位再工作。假如你是快毕业的博士生的话更不应该放弃。当ABD只会让你后悔终生。就算你自己不这么觉得，我们也会为你感到惋惜。（译者注：ABD就是All But Dissertaion，就是除了论文其它都准备好了的意思，引申为那些临门一脚放弃博士学位的人）
  
  很多学校甚至都不要求选修编译原理就可以得到计算机科学的学位，这是在是令人唏嘘不已。
  
  编译原理是一门重要的计算机科学课程的首要原因就是，它非常切实地将你之前学过的几乎所有东西都捏合在了一起。
  
  我当然不是在说其它计算机科学的课程就不重要。操作系统、机器学习、分布式计算、算法设计等其实都和编译原理一样重要。只不过学完那些课程后，你还不知道计算机是怎么工作的话，这就让我觉得编译原理真的应该是一门300级的必修课了。可惜要学好它需要太多的基础知识，要求大多数学校这么做有点不太现实。
  
  自己动手写编译器是改变世界的必由之路。
  其实它没你想得那么难，只不过它最后会变成一生的工作。这也没什么，只要你愿意，随时都可以停手。不过这样的人很少很少。通常最后都是因为时间、精力有限，而不得不放弃。不过就算这样，你的编程水平也已经远远甩开很多人了。
  还有，不管你的编译器是编译什么语言，你会真正了解掌握这门语言。没有其它捷径。不好意思！
  
  要是不懂编译原理，那也不必担心。我觉得你仍然可以是一个不错的程序员。只不过挑战一下极限总是好的吧！

### 3：摘录自“应聘Google”
  很多程序员对于Google这样的公司故意问一些没人知道答案的问题都有点恼羞成怒。很多自学成才的程序员在读了文章以后甚至感到很伤自尊。
  不过我明白，面试这个话题总是会伤害到一些人的自尊心的。这也是没办法的事情。我在文章里讲的东西对于绝大多数技术公司（微软、Google、亚马逊、苹果、Facebook）来讲都是比较准确的。**其实这些都是很基本的东西**，大多数都是计算机科学大二或大三本科的内容。真的不是什么高深的东西。
 
####  3.1：" 天哪，为什么我会撞上面试拒人团！"
  Google其实在这方面的失误是有名的，就是说，我们有时候会拒掉合格的候选人，因为就算错过，也比招一个不合格的人进来要好。这在业界也算是共识吧，只是各个公司的处理方式略有不同而已。Google的漏报率还是很高的。我没有具体的数字，但我认识很多绝对有资格的聪明人最后都没能通过面试。老实说这挺可惜的。
  不管怎样，我想说的是：**就算你这次没成功，也不代表你水平不够。所以没必要觉得沮丧。**
  就我的观察来看，这种情况完全是随机的，和技术经验什么的都没有关系。涉及的因素多种多样。
  
  每个”资深“面试官心里都会有一套主题，甚至是特定的题目，让他们觉得可以准确地判断应聘者的水平。每个面试官的题目都可能非常不一样，甚至完全不重叠。
  举个随处可见的经典例子：面试官A喜欢问C++的各种细节，文件系统，网络协议，具体数学。而面试官B喜欢问Java的各种细节，设计模式，单元测试，Web框架，项目管理。任何应聘者如果同时遇到A和B，他得到的结果就很可能非常不同。说难听点，A和B可能互相都看不上眼呢。只不过正好他们都是在面试官C手上通过的。C最喜欢问数据结构，Unix命令，进程和线程的区别等，A和B正好都能答上来。
  基本上你能通过一家技术公司的面试都是这种情况。你正好答上来了那些问题罢了。这是面试本质上的缺陷，就算你是阿兰.图灵，也一样会碰到看不上你的面试官。
  所以不管你去哪家软件公司面试，都要做好心理准备，**可能会很倒霉，撞上那么一两个可能会拒掉你的面试官。**面试过程不但会很艰难，最后还会被告知不适合那家公司，这种感觉确实不好受。**但是千万不要被这种感觉打败，其实根本没什么大不了的。**
  然后你应该潜心准备6-12个月，重新应聘。对待这种错漏的案例，我们（至少我周围认识的人里）也没有更好的办法了。忘记过去，一切重新来过。很多人是尝试两三次以后才进来的，这些可都是很牛的人哦。
  **所以你也一样做得到。**
  
####  3.2：" 面试技巧"
  长期热身的意思是：在面试之前要复习一到两个星期。要让自己适应进入在白板前解决问题的"模式"。
  我知道最佳的长期热身方式有以下两种：
  （1）**好好读一本讲数据结构和算法的书。**因为这能强化你分辨问题的能力。例如，他们问你怎么给美国地图上不同的州着上不同颜色的时候，你能够立刻反应出这是一个图着色问题。所以从准备面试的角度来讲，能够识别出问题属于哪个类型，最好用什么算法和数据结构来解释至关重要的。史蒂芬.斯基纳的**《算法设计手册》**就是我准备面试的最爱，每个程序员都应该弄懂它。还有一些面试官则比较推崇**《算法导论》**。这的确是一本经典著作，价值不言而喻，但是恐怕两个星期是读不完的。
  （2）找个朋友来面你。请朋友来随机给你出面试题，你应该能够**立刻在白板上写出来**。不要背惰性打倒，坚持写完才能结束。咬牙坚持才是王道。
  
  短期热身的意思是：面试前一天晚上要休息好，然后当天早上要做一些密集快速的热身练习。
  尽可能使自己**保持警醒**，充分热身。不要身体没热就上赛场。读读笔记，**做两道题练练手**。
  
####  3.3：" 准备技术面试的建议"
  **算法复杂度：**大0是一定要懂的。它最多就是计算理论里开头的一章内容，所以一定要去读。你能读懂的。
  
 ** 排序：**知道排序是怎么回事。不要写冒泡排序。至少要了解一个负责度n*log(n)的排序算法的细节，能记住两个更好（比如快速排序和归并排序）。归并排序在那些快速排序不好用的情况下通常都很有用，所以也应该了解一下。无论如何，也不要在面试的时候去排序一个链表。
  
  **哈希表：**哈希表可以说是人类已知的最重要的数据结构。一定要弄明白它的原理是什么。它也就是数据结构书里的一个章节，去读吧。你要能够做到在一场面试里，用自己最熟悉的语言，只用数组来实现它。
  
  **树：**必须弄懂。这是基础，我真的不想说，但是有些人连最基本的怎么构造一棵树，怎么遍历，怎么操作的算法都没搞明白就来面试，太丢人了。你至少也应该熟悉二叉树、n叉树、trie树。树应该是长期热身里最好的练习题资源了。
  至少要熟悉一种平衡二叉树，可以是红黑树、伸展树、AVL树。而且必须掌握实现细节。
  树的遍历算法也要知道，BFS和DFS，还要了解前序、中序、后序遍历的区别。
  可能你树用的很少，但那是因为你在回避它。只要你弄懂了树，就不用再害怕啦。好好学吧！
  
  **图：**图真的非常非常重要。远超你的想象。就算你已经觉得它很重要很可能它的重要性还是超过了你的认知。
  在内存里表示图的方法基本上有3种（对象和指针、矩阵、邻接表），每种表示都要熟悉，并且知道它们的优缺点。
  你应该了解基本的图遍历算法：广度优先搜索和深度优先搜索。知道它们的负责度、优缺点，以及具体的实现代码。
  然后还应该根据情况了解一些更高级的算法，如Dijkstra算法和A*算法。无论在游戏编程还是在分布式计算中，这些都是非常了不起的算法，所以应该了解一下。
  每次遇到问题，首先应当考虑的就是图算法。它们是任何关系最基本、最灵活的表示方法，任何有点意思的设计问题可以说有一半的机会会涉及图算法。
  
  **其它数据结构：**只要脑袋装得下，就尽可能多地掌握一点各种数据结构和算法。特别是那些著名的NP问题，如旅行商问题和背包问题。在面试官问到这类问题的时候，你要能认出它们来。你应该知道NP完全问题是什么意思。一定要好好读数据结构书，能记多少记多少，相信我，你不会失望的。
  
  **数学：**有些面试官会问一点基本的离散数学
  **操作系统：**你只要知道进程、线程、并发这些概念就够了。很多面试官都会问到这些基础内容，所以你应该了解它们。掌握锁的概念，互斥锁，信号量，管程工作机制的工作方式。知道什么是死锁，什么是活锁，怎么避免它们。知道进程需要哪些资源，线程需要哪些资源，上下文切换是怎么进行的，操作系统和底层硬件是怎么触发上下文切换的。知道一点调度是怎么回事。
  现在多核正在变得越来越流行，要是你连基本的"现代"并发结构也不理解的话，那就真的是史前动物了。这方面我渡过最实用的书是道格.李的《Java并发编程》。
  
  我上面提到的这些东西其实都是**必备知识**：要是这些都不懂，基本过不了面试。离散数学的要求或许没那么严格，但是一点也不懂的话好像也说不过去。剩下的内容都要融汇贯通，这样就算**达到面试及格线**了。根据不同面试官的风格，面试的难度可能会很高，也可能简单得多。
  这真的**要看你的运气如何**。你觉得自己是不是有运气的人？来试试看吧！
  
### 3：摘录自“总结”
  好的程序员之所以出色是因为熟能生巧。
  
  只要你愿意，随时都可以学习新语言。
  
  Emacs很难掌握，但却是受益终身的投资。
  
  离开舒适区，时不时地学点新东西。
  
  为自己写点东西，只有这样你才知道那是不对的。
  
  多笑一点，这很健康，也让人感觉良好。